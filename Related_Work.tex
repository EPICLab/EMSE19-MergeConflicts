%!TEX root = main.tex

\section{Related Work}\label{related_work}

\subsection{Collaboration}

Gousios et al. \cite{integrator_perspective} conduct a study in which they ask integrators to describe difficulties in maintaining their projects and code contributions. 
They showed that integrators have problems with their tools, have trouble with non-atomic changesets, and rank \textit{git knowledge} in the top 30\% of their list of biggest challenges. 
Gousios et al.~\cite{gousios2016work} additionally conducted a study into the challenges of the pull-based model from the perspective of contributors. 
They found that most challenges relate to code contribution, the tools and model used to contribute, and the social aspects of contributing (specifically highlighting merge conflicts).
These works focus on the collaborative processes that go into contributing to open-source projects and operating as integrators within them, whereas we examine the processes and issues inherent to merge conflicts and the tools built to support their resolution.

Guzzi et al.~\cite{Guzzi2015} conducted an exploratory investigation and tool evaluation for supporting collaboration in teamwork within the IDE.
They found that developers working within a variety of companies were able to quickly and easily resolve merge conflicts, and did this using merge tools.
However, they also note that although automatic merging was used, their participants also manually checked each conflict and suggest that this reveals some mistrust of tools.
Guzzi et al. further explain that their interviewees avoid merge conflicts by using strict policies and software modularity.
Their results complement our findings that toolset mistrust is a major concern, and that standards need to be implemented in order to avoid complex merge conflicts.

Begole et al.~\cite{begole_work_2002} investigate the work rhythms of developers.
They use minute-by-minute records of computer activity coupled with locality of the activity, calendar appointments, and e-mail activities to provide meaningful visualizations for group coordination.
The passive nature of developers' interaction with these visualizations requires users to engage and coordinate with each other, which differs from version control systems that actively support the software development process.
Finally, Meyer et al.~\cite{meyer_work_2017} look at the activities of developers, their productivity and context switching.
They identify patterns in activity that can help developers collaborate more effectively, and find that developers spend about a fourth of their time on coding related activities and another fourth of their time on collaborative activities.
These works highlight the importance of collaboration and coordination in the daily activities of developers, which provide impetus for our examination of developers adaptations in the presence of merge conflicts, which represents a breakdown in those activities.

\subsection{History Understanding and Navigation}

Codoban et al.~\cite{Mihai_lenses} seek to evaluate developer understanding and usage of code history. 
Our results show that tool support during history exploration factors a moderate amount into the difficulty of a merge conflict (N10). 
This result independently verifies their findings that developers experience tool limitations in usability (I1) and history visualization (I4).

Ragavan et al.~\cite{ragavan_pfis-v_2017} propose an Information Foraging Theory (IFT) model for how developers forage in the presences of history (in their paper they refer to this as ``variations'').
This model highlights the needs of developers attempting to understand variations in code, whereas we examine the methods and strategies that developers employ prior to encountering a merge conflict and the processes for evaluating their resolutions.

While these studies provide an insight into how developers use, explore, and understand history, they do not approach any of the problems that collaboration can bring to software development.
We aim to examine the complete process from awareness of a merge conflict to it's eventual resolution.

\subsection{Better Merge Conflict Resolution}

Currently, all version control systems treat source code files as text.
Therefore, merging is done at a textual level, ignoring all structure that the files might contain.
Several researchers have looked at ways to improve this status quo.

Westfechtel~\cite{westfechtel_structure-oriented_1991} propose a merging technique that uses the structural (i.e. lexical) information of a language when performing a merge. However, such tools are language dependent and the required algorithms are expensive to run.
Apel et al.~\cite{apel_structured_2012-1, apel_semistructured_2011} propose \emph{JDime}, which improves existing structured merging techniques by only using structural information when the unstructured (i.e. text only) merge has failed.
Binkley et al.~\cite{binkley_program_1995} propose using call graph information to correctly merge different versions of the program.

Lippe and van Oosterom~\cite{lippe_operation-based_1992} go a different way.
They propose a new merging technique, \emph{operation-based merging} that would replay the changes that were performed on the two branches, in the order in which they were performed.
Dig et al.~\cite{danny2008tse} uses this technique and shows empirically that many more merge conflicts could be solved by a tool that understood the semantics of change operations.

These studies seek to improve the performance and reliability of merging tools, which complement our results which show that toolset mistrust is a major concern among developers.
By addressing the quality and consistency of the algorithms and tools available for merge conflicts, tool builders can hopefully improve developer trust in the future.

\subsection{Workspace Awareness} 

Biehl et al.~\cite{biehl_fastdash:_2007} propose \emph{FastDASH}, a tool that fosters awareness between members of a team. 
FastDASH provides a dashboard that shows the files that are checked out, modified, and staged by other members of the team.
da Silva et al.~\cite{da_silva_lighthouse:_2006} propose \emph{Lighthouse} to show the changes being made at the design level.
Their tools presents all changes from the perspective of changes to the model (in the form of UML diagrams) of all of the developers project.
While all these approaches provide awareness of potential conflicts, they require the developer to actively monitor and discern if a conflict is likely or has occurred.

Sarma et al.~\cite{palantir, sarma_palantir:_2003} go a step further and propose \emph{Palant\'{i}r}.
Palant\'{i}r monitors other developer's workspaces, and, depending on the changes, will notify the developer, in a non-obtrusive manner, if a conflict has happened.
Similarly, Hatori and Lanza~\cite{hattori2010syde} propose \emph{Syde} that monitors the changes at an Abstract Syntax Tree (AST) level.
This allows the tool to give more precise information to the developer.

Brun et al.~\cite{Brun2011} propose \emph{Crystal}, which monitors selected branches in the repository. 
Crystal preemptively merges the branches in the background and will notify the developers of any conflicts that arise. 
It detects both \emph{direct} conflicts (changes to the same line), and \emph{indirect} conflicts (changes to a different line that cause build or test failures).
Guimara\~{e}s et al.~\cite{Guimaraes} propose \emph{WeCode}, which also merges in uncommitted code, in order to improve the time to detection of a merge conflict.

Servant et al.~\cite{servant_casi:_2010} proposes \emph{CASI}, that uses visualization to help developers detect conflict early.
CASI shows all the program elements that are influenced by the changes made in the team, so that developers can coordinate more efficiently.

Kasi and Sarma~\cite{kasi_cassandra:_2013} take a more proactive approach and propose a novel task scheduling approach that aims to minize the number of conflicts. 
\emph{Cassandra} uses developer preferences, task and file dependencies to schedule tasks so that they are less likely to conflict.
