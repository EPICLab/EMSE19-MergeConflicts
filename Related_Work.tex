%!TEX root = main.tex

\section{Related Work}\label{related_work}

\subsection{Collaboration}

Gousios et al. \cite{integrator_perspective} conduct a study in which they ask integrators to describe difficulties in maintaining their projects and code contributions. 
They showed that integrators have problems with their tools, have trouble with non-atomic changesets, and rank \textit{git knowledge} in the top 30\% of their list of biggest challenges. 
Gousios et al.~\cite{gousios2016work} additionally conducted a study into the challenges of the pull-based model from the perspective of contributors. 
They found that most challenges relate to code contribution, the tools and model used to contribute, and the social aspects of contributing (specifically highlighting merge conflicts).
These works focus on the collaborative processes that go into contributing to open-source projects and operating as integrators within them, whereas we examine the issues inherent to merge conflicts and the tools built to support their resolution.

Guzzi et al.~\cite{Guzzi2015} conducted an exploratory investigation and tool evaluation for supporting collaboration in teamwork within the IDE.
They found that developers working within a variety of companies were able to quickly and easily resolve merge conflicts, and did this using merge tools.
However, they also note that although automatic merging was used, their participants also manually checked each conflict and suggest that this reveals some mistrust of tools.
Guzzi et al. further explain that their interviewees avoid merge conflicts by using strict policies and software modularity.
Their results complement our findings that toolset mistrust is a major concern, and that standards need to be implemented in order to avoid complex merge conflicts.

Begole et al.~\cite{begole_work_2002} investigate the work rhythms of developers. 
This can be used to augment the developer's calendars, so it is for them to coordinate.
Finally, Meyer et al.~\cite{meyer_work_2017} look at the activities of developers, their productivity and context switching.
They identify patterns in activity that can help developer collaborate more effectively. 

\subsection{History Understanding and Navigation}

Codoban et al.~\cite{Mihai_lenses} seek to evaluate developer understanding and usage of code history. 
Our results show that tool support during history exploration factors into the difficulty of a merge conflict a moderate amount (N10). 
This result independently verifies their findings that practitioners experience tool limitations in usability (I1) and history visualization (I4).

Ragavan et al.~\cite{ragavan_pfis-v_2017} proses an Information Foraging Theory (IFT) model of how developers forage in the presences of history (in their paper they refer to this as ``variation'').

While these studies provide an insight into how developers use, explore and understand history, they do not approach any of the problems that collaborative development can bring.

%\subsection{Tool evaluation}

\subsection{Better Merge Conflict Resolution}

Currently, all version control systems treat source code files as text.
Therefore, merging is done at a textual level, ignoring all structure that the files might have.
Several researchers have looked at ways to improve this status-quo.

Westfechtel~\cite{westfechtel_structure-oriented_1991} proposes a merging technique that uses the structural (lexical) information of a language when performing a merge. However, such tools are language dependent and the algorithms required are expensive to run.
Apel et al.~\cite{apel_structured_2012-1, apel_semistructured_2011} proposes \emph{JDime}, improves existing structured merging techniques by only using structural information when the unstructured (text only) merge has failed.
Binkley et al.~\cite{binkley_program_1995} proposes using call graph information to correct merge different versions of the program.

Lippe and van Oosterom~\cite{lippe_operation-based_1992} go a different way. They propose a new merging technique, \emph{operation-based merging} that would replay the changes that were performed on the two branches, in the order in which they were performed.

\subsection{Workspace awareness} 

Biehl et al.~\cite{biehl_fastdash:_2007} propose \emph{FastDASH}, a tool that fosters awareness between members of a team. 
FastDASH provides a dashboard that shows the files that are checked out, modified etc. by other members of the team.
da Silva et al.~\cite{da_silva_lighthouse:_2006} propose \emph{Lighthouse} that shows the changes being made a design level.
Their tools presents the changes being made as changes to the model (in the form of UML diagrams) to all the developers project.
While all these approaches provide awareness of potential conflicts, but it's still up to the developer to monitor and figure out if a conflict is likely or has occurred.

Sarma et al.~\cite{palantir, sarma_palantir:_2003} goes a step further and propose \emph{Palant\'{i}r}.
Palant\'{i}r monitors other developer's workspaces, and, depending on the changes, will notify the developer, in a non-obtrusive manner, if a conflict has happened.
Similarly, Hatori and Lanza~\cite{hattori2010syde} propose \emph{Syde} that monitors the changes at an Abstract Syntax Tree (AST) level.
This allows the tool to give more precise information to the developer.

Brun et al.~\cite{Brun2011} propose \emph{Crystal}, which monitors selected branches in the repository. 
Crystal merges the branches in the background and will notify the developers of any conflicts that arise. 
It detects both \emph{direct} conflicts (changes to the same line), and \emph{indirect} conflicts (changes to different line that cause build or test failures).
Guimara\~{e}s et al.~\cite{Guimaraes} propose \emph{WeCode}, which also merges in uncommitted code, in order to improve the time to detection of a merge conflict.

Servant et al.~\cite{servant_casi:_2010} proposes \emph{CASI}, that uses visualization to help developers detect conflict early.
CASI shows all the program elements that influenced by the changes made in the team, so developers can coordinate better.

Kasi and Sarma~\cite{kasi_cassandra:_2013} take a more proactive approach and propose a novel task scheduling approach that aims to minize the number of conflicts. 
\emph{Cassandra} uses developer preferences, task and file dependencies to schedule tasks so that they are less likely to conflict.
